WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.569
假设要测试这样一个函数

00:00:03.569 --> 00:00:07.884
找到小于等于且最接近某个数字的完美平方

00:00:07.884 --> 00:00:09.900
第一种方法可能是

00:00:09.900 --> 00:00:14.050
在终端或 Jupyter Notebook 中以交互方式测试 就像这样

00:00:14.050 --> 00:00:17.565
首先 从文件中导入函数

00:00:17.565 --> 00:00:20.205
现在 开始使用不同的值进行测试

00:00:20.204 --> 00:00:22.144
尝试一下 5

00:00:22.144 --> 00:00:27.004
应该返回 4 因为其是小于等于且最接近 5 的完美平方

00:00:27.004 --> 00:00:29.059
试试负数

00:00:29.059 --> 00:00:32.664
应该返回 0 结果也确实如此

00:00:32.664 --> 00:00:34.975
现在 尝试一个完美平方值

00:00:34.975 --> 00:00:38.560
9 应该返回 9

00:00:38.560 --> 00:00:40.359
再试一个

00:00:40.359 --> 00:00:42.164
23 返回 16

00:00:42.164 --> 00:00:46.390
不错! 这确实测试了函数的功能

00:00:46.390 --> 00:00:49.755
但这仍然是一种糟糕的测试方式 因为其不可重复

00:00:49.755 --> 00:00:52.295
要求手动输入

00:00:52.295 --> 00:00:55.969
也并没有告诉你 返回的是否为正确答案

00:00:55.969 --> 00:00:59.030
想象一下 你需要测试数百个函数

00:00:59.030 --> 00:01:02.280
并且在迭代项目时反复测试

00:01:02.280 --> 00:01:07.710
可以看出这种方法对于上述情况来说 有多么低效和不可靠

00:01:07.709 --> 00:01:12.639
这种方法之后 你可能会考虑将测试代码放入文件中 使其可重复

00:01:12.640 --> 00:01:14.500
最后写出这些内容

00:01:14.500 --> 00:01:17.810
这样好一点 因为测试代码现在位于文件中

00:01:17.810 --> 00:01:21.430
可以重复运行相同的测试 不需要太多的工作

00:01:21.430 --> 00:01:24.635
但它仍然没有告诉你是否得出了正确答案

00:01:24.635 --> 00:01:26.015
你还需要检查

00:01:26.015 --> 00:01:27.730
5 对应的结果 4

00:01:27.730 --> 00:01:29.500
这是正确的 -12 嗯对的

00:01:29.500 --> 00:01:31.855
结果是 0 还是很慢

00:01:31.855 --> 00:01:35.725
如果我们在每次结果中打印出预期的正确答案

00:01:35.724 --> 00:01:39.169
我们就有了更明确的方式来检查结果

00:01:39.170 --> 00:01:41.510
但是仍然需要手动检查

00:01:41.510 --> 00:01:45.995
对比函数返回的结果和预期的答案

00:01:45.995 --> 00:01:50.050
如果需要经常进行大量的单元测试 这并不理想

00:01:50.049 --> 00:01:56.049
我们可以使用 assert 来确保每个结果与正确答案相同

00:01:56.049 --> 00:01:59.914
这样做要好得多 因为它会自动检查我们的结果

00:01:59.915 --> 00:02:03.335
但是看看出现失败时会发生什么

00:02:03.334 --> 00:02:08.180
比如说我没有用等号 只是放了一个小于符号

00:02:08.180 --> 00:02:11.500
结果显示很乱 并且会使程序停止运行

00:02:11.500 --> 00:02:14.810
理想情况下 测试应运行完所有单元测试

00:02:14.810 --> 00:02:18.215
让你知道哪些失败了 哪些成功了

00:02:18.215 --> 00:02:21.185
如果每次失败都会停止运行 就不是这样的情况了

00:02:21.185 --> 00:02:23.955
在发生此次失败后的任何测试

00:02:23.955 --> 00:02:25.830
我们都看不到结果

00:02:25.830 --> 00:02:29.860
另外 失败的信息太过混乱 很多内容并不需要

00:02:29.860 --> 00:02:32.570
幸运的是 Python 有很棒的工具

00:02:32.569 --> 00:02:36.400
可以用来创建有效的单元测试

