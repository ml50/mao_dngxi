WEBVTT
Kind: captions
Language: zh-CN

00:00:04.219 --> 00:00:07.379
测试驱动开发就是

00:00:07.379 --> 00:00:10.304
在编写需要测试的代码之前先编写测试用例

00:00:10.304 --> 00:00:13.800
这意味着测试最初会失败

00:00:13.800 --> 00:00:17.400
而在测试通过时 你就能了解到自己完成了任务

00:00:17.399 --> 00:00:20.070
这种开发代码的方式有很多优势

00:00:20.070 --> 00:00:24.149
使其成为了软件工程的标准实践

00:00:24.149 --> 00:00:26.014
举个简单的例子

00:00:26.015 --> 00:00:28.589
假设你要编写一个函数

00:00:28.589 --> 00:00:31.620
检查字符串是否为有效的电子邮件地址

00:00:31.620 --> 00:00:36.289
你可以想到一些要考虑的因素 例如字符串是否包含

00:00:36.289 --> 00:00:40.884
一个 @ 符号和一个句点 然后写出检测这些内容的函数

00:00:40.884 --> 00:00:43.674
在终端中手动测试

00:00:43.674 --> 00:00:47.404
输入一个有效和一个无效的电子邮件地址

00:00:47.405 --> 00:00:50.600
来确保它可以正常工作 确实可以

00:00:50.600 --> 00:00:54.905
你又尝试了更多有效和无效的电子邮件地址

00:00:54.905 --> 00:00:57.490
其中一个给出了错误的结果

00:00:57.490 --> 00:01:01.679
你意识到自己忘记在函数中考虑边缘情况

00:01:01.679 --> 00:01:04.280
所以返回去加入这种情况

00:01:04.280 --> 00:01:08.030
然后你使用另一个忘记考虑的边缘情况测试功能

00:01:08.030 --> 00:01:12.655
然后再次编辑函数来解决问题

00:01:12.655 --> 00:01:15.855
其实你可以不用来回做这些工作

00:01:15.855 --> 00:01:20.150
而是尝试创建一个检查所有不同场景和边缘情况的测试

00:01:20.150 --> 00:01:24.780
甚至在编写函数之前就开始考虑这些内容

00:01:24.780 --> 00:01:28.760
这样 当你开始实现函数时

00:01:28.760 --> 00:01:32.960
可以运行此测试 来获得有关函数是否有效的即刻反馈

00:01:32.959 --> 00:01:37.604
针对所有你可以想到的调整函数的方式

00:01:37.605 --> 00:01:39.375
如果测试通过

00:01:39.375 --> 00:01:42.594
你就知道自己已经完成实现

00:01:42.594 --> 00:01:45.079
将来 当你重构该函数

00:01:45.079 --> 00:01:48.689
或修改程序的其他部分

00:01:48.689 --> 00:01:54.319
你可以继续运行此测试 来确保函数仍然按预期运行

00:01:54.319 --> 00:01:57.799
这也有助于确保你的函数行为

00:01:57.799 --> 00:02:01.155
是可重复的 无论外部参数如何

00:02:01.155 --> 00:02:03.280
比如硬件和时间

00:02:03.280 --> 00:02:05.849
当你第一次开始编写测试时

00:02:05.849 --> 00:02:08.989
会很慢 你会更想

00:02:08.990 --> 00:02:12.320
在编写测试之前先编写实现代码

00:02:12.319 --> 00:02:15.199
坚持练习 通过实践

00:02:15.199 --> 00:02:16.799
你会变得更快

00:02:16.800 --> 00:02:22.600
最终你将能够在很短的时间内编写各种测试

