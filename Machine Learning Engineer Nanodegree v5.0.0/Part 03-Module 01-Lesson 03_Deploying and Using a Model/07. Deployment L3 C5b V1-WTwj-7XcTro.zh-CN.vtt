WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.615
在上个视频中 我们对上节课的迷你项目进行了扩展

00:00:03.615 --> 00:00:05.775
即部署了该项目

00:00:05.775 --> 00:00:08.669
当然 我们没有怎么使用部署的端点

00:00:08.669 --> 00:00:12.379
只是用它来测试模型

00:00:12.380 --> 00:00:15.585
现在将一切都整合到一起

00:00:15.585 --> 00:00:19.170
为了使网络应用能使用该端点

00:00:19.170 --> 00:00:20.640
在介绍的时候我提到

00:00:20.640 --> 00:00:23.760
我们需要攻克两个问题

00:00:23.760 --> 00:00:27.000
第一个是模型端点要求输入是

00:00:27.000 --> 00:00:30.928
用词袋表示的影评

00:00:30.928 --> 00:00:33.920
但是 网络应用允许用户

00:00:33.920 --> 00:00:37.625
以字符串的形式输入影评如何实现呢？

00:00:37.625 --> 00:00:41.359
第二个问题是安全性

00:00:41.359 --> 00:00:45.859
部署的 StageMaker 端点仅允许

00:00:45.859 --> 00:00:47.658
特定的对象访问 即向 AWS 验证身份

00:00:47.658 --> 00:00:51.768
并且有权使用 StageMaker 端点的对象

00:00:51.770 --> 00:00:54.020
这对于简单的网络应用来说 似乎有点麻烦

00:00:54.020 --> 00:00:57.393
所以我们将新建一个端点

00:00:57.594 --> 00:00:59.533
任何人都可以访问该端点

00:00:59.533 --> 00:01:02.414
它将接受字符串输入

00:01:02.414 --> 00:01:04.900
对数据进行处理

00:01:04.900 --> 00:01:09.560
然后将处理的影评发送给模型

00:01:09.560 --> 00:01:10.885
获取结果

00:01:10.885 --> 00:01:12.974
并将结果返回给原始调用者

00:01:13.174 --> 00:01:16.049
这幅图表很好地总结了整个过程

00:01:16.049 --> 00:01:17.435
这是网络应用

00:01:17.435 --> 00:01:20.269
网络应用从用户那接受字符串

00:01:20.269 --> 00:01:24.408
将字符串发送给我们将创建的新端点

00:01:24.409 --> 00:01:28.010
新端点对影评进行额外的处理

00:01:28.010 --> 00:01:32.525
然后将处理过的影评发送给模型

00:01:32.525 --> 00:01:34.555
模型做出预测

00:01:34.555 --> 00:01:39.118
并将预测返回新创建的端点

00:01:39.319 --> 00:01:42.168
端点将结果返回给应用

00:01:42.170 --> 00:01:43.768
然后显示给用户

00:01:43.968 --> 00:01:47.030
为了实现这个新端点

00:01:47.030 --> 00:01:50.118
首先我们将使用 Lambda

00:01:50.319 --> 00:01:55.504
然后使用 API Gateway 针对 Lambda 函数创建一个接口

00:01:55.504 --> 00:01:58.239
先介绍下 Lambda

00:01:58.239 --> 00:02:02.143
Lambda 属于函数即服务

00:02:02.343 --> 00:02:06.949
也就是说 与其创建一个服务器

00:02:06.950 --> 00:02:09.275
并一直运行 甚至暂时还不需要用到该服务器

00:02:09.275 --> 00:02:12.033
你可以告诉 Amazon

00:02:12.033 --> 00:02:17.228
每当发生特定的事件时 就运行特定的函数

00:02:17.229 --> 00:02:20.229
这样的话 不用为一直运行的服务器付费

00:02:20.229 --> 00:02:24.489
只需在每次函数运行时付费

00:02:24.490 --> 00:02:26.560
但是在设置 Lambda 函数之前

00:02:26.560 --> 00:02:29.338
我们先看看需要怎么处理数据

00:02:29.538 --> 00:02:32.119
首先 Lambda 函数将接收一个字符串

00:02:32.120 --> 00:02:35.404
其中包含影评

00:02:35.604 --> 00:02:38.118
对我们来说 假设 test_review

00:02:38.120 --> 00:02:40.925
是将发送给 Lambda 函数的字符串

00:02:40.925 --> 00:02:42.989
这条影评很负面

00:02:43.188 --> 00:02:45.650
首先需要删除

00:02:45.650 --> 00:02:48.929
字符串中的所有 HTML 格式标记

00:02:49.128 --> 00:02:52.745
以及所有的标点符号

00:02:52.745 --> 00:02:54.155
之前

00:02:54.155 --> 00:02:56.900
我们编写了一个函数 叫做 review_to_words()

00:02:56.900 --> 00:03:00.499
它仅使用 Python 的内置正则表达式模块就可以删除标点和 HTML 标记

00:03:00.699 --> 00:03:03.829
如果对示例影评调用此方法

00:03:03.830 --> 00:03:05.459
并输出结果

00:03:05.658 --> 00:03:09.438
可以看到返回了清理后的影评

00:03:09.438 --> 00:03:13.465
接着 需要用词袋表示影评

00:03:13.465 --> 00:03:16.908
我们需要一个词汇表

00:03:16.908 --> 00:03:21.908
我们之前通过查看训练集中最常出现的字词创建了词汇表

00:03:21.908 --> 00:03:23.638
下面我们将计算

00:03:23.639 --> 00:03:27.993
词汇表中的每个字词出现在影评中的次数

00:03:27.995 --> 00:03:32.462
然后创建一个表示这一信息的序列

00:03:32.462 --> 00:03:34.608
这一步很简单

00:03:34.610 --> 00:03:36.740
已经在这个方法中实现了

00:03:36.740 --> 00:03:40.460
传入输入（整洁的影评）

00:03:40.460 --> 00:03:47.405
和词汇表字典后 结果是影评的词袋编码

00:03:47.405 --> 00:03:51.794
当然 如果输出这些词袋编码

00:03:51.794 --> 00:03:53.264
看不出来是什么意思

00:03:53.264 --> 00:03:57.558
因为它只是一个向量 长度等于词汇表的大小

00:03:57.560 --> 00:03:58.818
再次确认下

00:03:58.818 --> 00:04:02.328
影评的词袋编码

00:04:02.330 --> 00:04:04.280
长度是否正确

00:04:04.280 --> 00:04:06.905
结果与之前创建的词汇表大小一致

00:04:06.905 --> 00:04:10.443
好的现在 我们将词袋格式的影评

00:04:10.443 --> 00:04:15.024
发送给模型 看看会发生什么

00:04:15.025 --> 00:04:18.819
当然 我们在上个视频中关闭了端点

00:04:18.819 --> 00:04:20.403
所以需要重新开启端点

00:04:20.403 --> 00:04:22.348
现在端点在运行了

00:04:22.350 --> 00:04:27.290
我们可以将词袋格式的影评发送给它 看看会发生什么

00:04:27.290 --> 00:04:28.685
之前

00:04:28.685 --> 00:04:33.370
我们使用 xgb_predictor 对象调用端点

00:04:33.370 --> 00:04:36.454
但是在要创建的 Lambda 函数中

00:04:36.454 --> 00:04:39.858
我们无法访问这个 xgb_predictor 对象

00:04:39.860 --> 00:04:43.610
所以需要使用 SageMaker 接口本身

00:04:43.610 --> 00:04:48.095
我们可以获取指向 sagemaker-runtime 的对象

00:04:48.095 --> 00:04:51.050
获取后

00:04:51.050 --> 00:04:55.009
利用创建的端点的名称（可以在这里找到）...

00:04:55.009 --> 00:05:00.230
我们可以调用 invoke_endpoint 方法

00:05:00.230 --> 00:05:02.569
指定端点的名称 要发送的数据的格式

00:05:02.769 --> 00:05:04.213
以及数据本身

00:05:04.213 --> 00:05:05.819
看看发生了什么

00:05:05.819 --> 00:05:07.153
似乎出现了错误

00:05:07.153 --> 00:05:08.459
为何出错了？

00:05:08.459 --> 00:05:10.334
向下滚动到底部

00:05:10.334 --> 00:05:12.408
可以看到参数验证失败了

00:05:12.410 --> 00:05:14.480
说明调用端点时

00:05:14.480 --> 00:05:17.754
用到的某些参数不正确

00:05:17.754 --> 00:05:20.670
看看 Body 的值

00:05:20.670 --> 00:05:22.740
这看起来不像 CSV 文件

00:05:22.740 --> 00:05:25.694
我们告诉 SageMaker 我们将发送 CSV 文件

00:05:25.694 --> 00:05:28.334
但是我们发送的是整数列表

00:05:28.334 --> 00:05:31.608
所以我们需要序列化此对象

00:05:31.610 --> 00:05:35.204
然后才能正确地调用 invoke_endpoint 方法现在序列化该对象

00:05:35.403 --> 00:05:38.449
在这里 我们指定了端点的名称

00:05:38.449 --> 00:05:41.629
告诉 SageMaker 我们将发送的数据类型

00:05:41.629 --> 00:05:44.189
然后序列化该数据

00:05:44.189 --> 00:05:48.634
方法是将词袋向量中的每个条目连接到一起

00:05:48.634 --> 00:05:50.735
用逗号分隔它们

00:05:50.735 --> 00:05:53.194
调用该方法后 获得一个响应

00:05:53.194 --> 00:05:54.699
是什么样的响应？

00:05:54.699 --> 00:05:56.680
是一堆数据

00:05:56.680 --> 00:05:59.750
出现这些数据是因为

00:05:59.750 --> 00:06:02.959
我们使用 HTTP 端点与模型通信

00:06:02.959 --> 00:06:05.528
端点只是一个 URL

00:06:05.528 --> 00:06:06.668
但是在这里

00:06:06.670 --> 00:06:09.050
可以看到 Body 对象

00:06:09.050 --> 00:06:12.170
这个 Body 对象包含我们要寻找的真正信息

00:06:12.170 --> 00:06:15.365
我们可以读入该 Body 对象

00:06:15.365 --> 00:06:19.204
记得将结果转换成字符串 准确率如何？

00:06:19.403 --> 00:06:21.629
0.378

00:06:21.629 --> 00:06:26.463
看来模型不认为这条影评是正面的

00:06:26.463 --> 00:06:28.868
实际上 模型认为是负面的

00:06:28.870 --> 00:06:31.079
这就是我们要在

00:06:31.278 --> 00:06:33.678
Lambda 函数中完成的处理过程

00:06:33.680 --> 00:06:38.680
接下来我们将设置 Lambda 函数

