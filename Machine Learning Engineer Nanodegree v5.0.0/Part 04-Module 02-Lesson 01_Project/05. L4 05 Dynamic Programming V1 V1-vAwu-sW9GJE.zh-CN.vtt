WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.549
在实现有效的 LCS 算法时

00:00:02.549 --> 00:00:07.514
建议采用矩阵和动态规划法

00:00:07.514 --> 00:00:10.064
动态规划是指将更大的问题

00:00:10.064 --> 00:00:13.424
拆分成多个子问题

00:00:13.425 --> 00:00:18.105
并创建一个完整的解决方案 不需要重复解决子问题

00:00:18.105 --> 00:00:20.535
这种方法假设你可以将大的 LCS 任务

00:00:20.535 --> 00:00:24.765
拆分成更小的任务并组合起来

00:00:24.765 --> 00:00:27.705
举个简单的字母比较例子

00:00:27.704 --> 00:00:31.814
假设答案是“ABCD”原文是“BD”

00:00:31.815 --> 00:00:36.314
一眼就能看出最长的字母子序列是 2

00:00:36.314 --> 00:00:39.149
B 和 D 在两个字符串中都按顺序出现了

00:00:39.149 --> 00:00:43.984
我们可以通过查看两个字符串中每个字母之间的关系算出这个结果

00:00:43.984 --> 00:00:47.179
这种技巧也可以应用到单个字词上

00:00:47.179 --> 00:00:48.924
而不仅仅是单个字母上

00:00:48.924 --> 00:00:51.634
在这个矩阵中 答案字母位于顶部

00:00:51.634 --> 00:00:54.574
原文字母位于左侧

00:00:54.575 --> 00:00:59.510
这个矩阵的列数和行数为字符串中的字母数量

00:00:59.509 --> 00:01:02.045
再加上一行和一列

00:01:02.045 --> 00:01:04.745
并在顶部和左侧填充了 0

00:01:04.745 --> 00:01:07.445
所以现在不是 2x4 矩阵

00:01:07.444 --> 00:01:09.454
而是 3x5 矩阵

00:01:09.454 --> 00:01:13.939
下面将问题拆分成更小的 LCS 问题并填充矩阵

00:01:13.939 --> 00:01:17.524
例如 先查看最短的子字符串

00:01:17.525 --> 00:01:21.219
A 和 S 的起始字母

00:01:21.219 --> 00:01:26.209
A 和 B 这两个字母之间最长的公共子序列是什么？

00:01:26.209 --> 00:01:27.694
因为这两个字母不匹配

00:01:27.694 --> 00:01:29.019
所以答案是 0

00:01:29.019 --> 00:01:32.375
在相应的单元格里填上 0

00:01:32.375 --> 00:01:34.564
然后看看下个问题

00:01:34.564 --> 00:01:37.579
AB 和 B 之间的 LCS 是多少？

00:01:37.579 --> 00:01:39.920
现在 B 和 B 匹配了

00:01:39.920 --> 00:01:42.650
在相应的单元格中填上值 1

00:01:42.650 --> 00:01:45.710
注意 我一次仅查看

00:01:45.709 --> 00:01:48.934
一列与一行是否有匹配的字母并获得匹配值

00:01:48.935 --> 00:01:51.019
如果继续沿着这行查看

00:01:51.019 --> 00:01:54.049
可以看到 B 仅这一次会匹配

00:01:54.049 --> 00:01:59.409
对于后面的问题 例如 ABCD 和 B 之间的 LCS 是多少？

00:01:59.409 --> 00:02:01.099
值都是 1

00:02:01.099 --> 00:02:04.009
因为一开始 B 和 B 匹配

00:02:04.010 --> 00:02:06.835
实际上 这个 1 将扩散到右侧

00:02:06.834 --> 00:02:08.719
使这行剩余的单元格也填写 1

00:02:08.719 --> 00:02:10.909
再看看第二行

00:02:10.909 --> 00:02:13.579
A 和 BD 不匹配

00:02:13.580 --> 00:02:17.090
然后 AB 和 BD 的确匹配

00:02:17.090 --> 00:02:20.210
但是这个 B 行和 D 列不匹配

00:02:20.210 --> 00:02:24.680
这种匹配实际上来自之前记录的 BB 匹配

00:02:24.680 --> 00:02:26.810
我们在上面的单元格中记录下来了

00:02:26.810 --> 00:02:30.770
所以可以将该值扩散到下面的单元格中

00:02:30.770 --> 00:02:34.885
在这行继续保持为 1 直到最终找到另一个匹配项

00:02:34.884 --> 00:02:37.824
即字母 D 第二次匹配后

00:02:37.824 --> 00:02:41.119
我们将之前最高的 LCS 值加一

00:02:41.120 --> 00:02:45.634
得出最长的公共子序列为 2 并填在矩阵的右下角

00:02:45.634 --> 00:02:47.479
要获得最终结果

00:02:47.479 --> 00:02:51.364
只需除以答案文本的长度来归一化

00:02:51.365 --> 00:02:52.730
答案有 4 个字母

00:02:52.729 --> 00:02:55.699
所以最终值为 0.5

00:02:55.699 --> 00:02:58.989
这个矩阵有几个比较有意思的地方

00:02:58.990 --> 00:03:04.159
我们发现 LCS 始终位于完整矩阵的右下角

00:03:04.159 --> 00:03:08.120
因为右下角表明我们已经到达两个文本的结尾

00:03:08.120 --> 00:03:10.640
我们已经考虑了所有可能的匹配情况

00:03:10.639 --> 00:03:14.089
我们从包含 0 的行和列开始

00:03:14.090 --> 00:03:15.770
在填充该矩阵时

00:03:15.770 --> 00:03:17.840
我们一次查看一个单元格

00:03:17.840 --> 00:03:19.955
我将此单元格称为感兴趣单元格

00:03:19.955 --> 00:03:23.575
我们只需处理两种情形情形一

00:03:23.574 --> 00:03:27.289
如果不匹配 例如字母 A 和 B

00:03:27.289 --> 00:03:29.750
则查看紧挨着感兴趣单元格的

00:03:29.750 --> 00:03:33.094
左侧和顶部单元格中的值

00:03:33.094 --> 00:03:36.634
然后用这两个值的最大值填充感兴趣单元格

00:03:36.634 --> 00:03:38.709
在此矩阵中 最大值为 0

00:03:38.710 --> 00:03:42.379
情形二 如果发现匹配项

00:03:42.379 --> 00:03:46.055
即 B 和 B 以及最后的 D 和 D

00:03:46.055 --> 00:03:48.920
我们获取感兴趣单元格左上角的单元格中的值

00:03:48.919 --> 00:03:53.599
并使其加一后填充到感兴趣单元格中

00:03:53.599 --> 00:03:56.688
我们可以通过这种不匹配和匹配情况

00:03:56.688 --> 00:03:59.284
动态地填充矩阵

00:03:59.284 --> 00:04:01.340
为了计算每个新的单元格值

00:04:01.340 --> 00:04:05.245
我们只需查看矩阵中一个或两个现有的值

00:04:05.245 --> 00:04:07.849
即利用 LCS 任务之前的解决方案

00:04:07.849 --> 00:04:12.629
得出最终的解决方案

