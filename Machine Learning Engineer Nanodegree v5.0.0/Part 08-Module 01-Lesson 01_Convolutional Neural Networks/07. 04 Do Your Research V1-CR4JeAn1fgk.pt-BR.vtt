WEBVTT
Kind: captions
Language: pt-BR

00:00:00.200 --> 00:00:03.235
Quando eu digito
"MLP para MNIST" no Google,

00:00:03.269 --> 00:00:04.670
aparecem alguns resultados,

00:00:04.704 --> 00:00:07.573
incluindo algumas implementações
de código.

00:00:07.607 --> 00:00:10.409
Este, do repositório
oficial do GitHub,

00:00:10.443 --> 00:00:12.011
parece uma fonte respeitável.

00:00:12.510 --> 00:00:14.046
Navegando neste código,

00:00:14.080 --> 00:00:16.549
vejo que eles importaram
o conjunto de dados MNIST

00:00:16.583 --> 00:00:21.520
e achataram as imagens
em um vetor de 784.

00:00:21.554 --> 00:00:23.856
Aqui parece que estão usando
uma camada oculta

00:00:23.890 --> 00:00:26.625
para converter este input
para 512 nós.

00:00:26.659 --> 00:00:29.829
Também vemos uma ativação
sendo aplicada,

00:00:29.863 --> 00:00:31.364
uma função ReLU.

00:00:31.398 --> 00:00:33.032
E temos outra camada oculta,

00:00:33.066 --> 00:00:35.101
também com 512 nós.

00:00:35.135 --> 00:00:37.737
Também vemos camadas Dropout
entre elas.

00:00:37.771 --> 00:00:42.208
Este 0,2 significa que tem 20%
de probabilidade de dropout.

00:00:42.242 --> 00:00:45.544
Ou de um nó ser desconectado
durante um ciclo de treino.

00:00:45.578 --> 00:00:47.680
Como já vimos,
camadas dropout são usadas

00:00:47.714 --> 00:00:49.415
para evitar
o sobreajuste de dados.

00:00:49.449 --> 00:00:52.284
Por último,
uma camada totalmente conectada

00:00:52.318 --> 00:00:56.355
produzindo um vetor de tamanho 10
para um número de classes.

00:00:56.389 --> 00:00:58.190
Quando olho uma fonte assim,

00:00:58.224 --> 00:01:00.626
primeiro tento ver
se faz sentido.

00:01:00.660 --> 00:01:03.829
Quanto mais camadas ocultas
eu incluir numa rede,

00:01:03.863 --> 00:01:07.066
mais padrões complexos
a rede conseguirá detectar.

00:01:07.100 --> 00:01:09.902
Mas não quero adicionar
complexidade desnecessária.

00:01:09.936 --> 00:01:12.940
Minha intuição me diz que,
para imagens pequenas,

00:01:12.973 --> 00:01:15.274
duas camadas ocultas
parecem ser razoáveis.

00:01:15.308 --> 00:01:17.710
Esta é só uma solução
para a tarefa

00:01:17.744 --> 00:01:19.879
de classificação de dígitos
escritos a mão.

00:01:19.913 --> 00:01:23.382
Os próximos passos ao encontrar
um problema como este são:

00:01:23.416 --> 00:01:26.118
continuar procurando,
para achar uma estrutura

00:01:26.152 --> 00:01:27.519
que seja atraente pra você,

00:01:27.553 --> 00:01:31.490
e, quando encontrar modelos
que você ache interessantes,

00:01:31.524 --> 00:01:34.160
escreva códigos para eles
e teste o desempenho.

00:01:34.194 --> 00:01:36.696
Este modelo que encontrei
é bom para mim,

00:01:36.730 --> 00:01:39.565
então vou prosseguir
com a definição de MLP

00:01:39.599 --> 00:01:42.302
com duas camadas ocultas
baseadas nesta estrutura.

