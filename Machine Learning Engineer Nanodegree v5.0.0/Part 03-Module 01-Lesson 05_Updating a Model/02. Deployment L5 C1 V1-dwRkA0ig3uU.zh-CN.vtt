WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.335
在这节课 我们将学习如何更新现有的端点

00:00:04.335 --> 00:00:07.770
假设你已经构建并部署了一个模型

00:00:07.770 --> 00:00:12.615
某个应用正在使用这个部署的模型

00:00:12.615 --> 00:00:15.075
之后 你可能想要更改模型

00:00:15.075 --> 00:00:18.150
但是不希望干扰

00:00:18.150 --> 00:00:21.870
应用使用该模型

00:00:21.870 --> 00:00:27.325
SageMaker 提供了更新模型的功能 并且不会中断服务

00:00:27.325 --> 00:00:30.350
此外 我们将详细了解

00:00:30.350 --> 00:00:33.545
创建端点配置的低阶方法

00:00:33.545 --> 00:00:36.950
这样可以增加灵活性

00:00:36.950 --> 00:00:40.340
并构建更复杂的端点

00:00:40.340 --> 00:00:42.890
例如 我们将学习如何创建

00:00:42.890 --> 00:00:46.940
向多个不同模型发送数据的端点

00:00:46.940 --> 00:00:48.650
这样可能很有用

00:00:48.650 --> 00:00:50.320
例如在进行 A/B 测试时

00:00:50.320 --> 00:00:53.060
在此过程中 我们将在 SageMaker 中

00:00:53.060 --> 00:00:57.140
混合使用高阶和低阶创建方法

00:00:57.140 --> 00:00:59.450
这样在你自己日后使用 SageMaker 时很有帮助

00:00:59.450 --> 00:01:02.390
因为高阶方法在某些情形下很有用

00:01:02.390 --> 00:01:06.350
但是有时候低阶方法可以带来灵活性

00:01:06.350 --> 00:01:09.845
首先 我们将再次查看 Boston Housing 数据集

00:01:09.845 --> 00:01:12.140
与之前在其他 notebook 中一样

00:01:12.140 --> 00:01:14.795
我们首先将创建一个 XGBoost 模型

00:01:14.795 --> 00:01:18.015
它会预测波士顿地区的房价中位数

00:01:18.015 --> 00:01:22.250
导入所有必要的模块 包括所有 SageMaker 模块

00:01:22.250 --> 00:01:23.570
然后加载数据

00:01:23.570 --> 00:01:27.005
拆分成训练 验证和测试集

00:01:27.005 --> 00:01:29.740
将数据保存到本地 notebook 实例中

00:01:29.740 --> 00:01:31.380
并上传到 S3

00:01:31.380 --> 00:01:34.350
然后训练模型

00:01:34.350 --> 00:01:37.950
首先创建一个 estimator 对象

00:01:37.950 --> 00:01:41.980
它会使用 XGBoost 容器进行训练

00:01:41.980 --> 00:01:46.370
然后为该算法设置超参数

00:01:46.370 --> 00:01:51.110
调用 fit() 将模型拟合到训练和验证数据上

00:01:51.110 --> 00:01:56.575
现在 调用 fit() 方法后的结果是创建了模型工件

00:01:56.575 --> 00:01:59.330
但是模型本身还没有创建

00:01:59.330 --> 00:02:02.240
在使用高阶方法时

00:02:02.240 --> 00:02:05.060
模型不会创建 除非需要创建

00:02:05.060 --> 00:02:11.030
例如 在创建转换对象或部署模型时

00:02:11.030 --> 00:02:13.610
因为我们想进一步控制部署的模型

00:02:13.610 --> 00:02:18.080
所以将使用低阶方法创建我们自己的模型

00:02:18.080 --> 00:02:20.960
设置好数据结构

00:02:20.960 --> 00:02:24.335
指定推理应该使用的容器

00:02:24.335 --> 00:02:28.340
并指向之前创建的模型工件

00:02:28.340 --> 00:02:31.610
然后要求 SageMaker 创建模型

00:02:31.610 --> 00:02:34.669
有了模型之后 我们可以创建端点配置

00:02:34.669 --> 00:02:38.625
这个端点配置与之前看到的一样

00:02:38.625 --> 00:02:44.165
只有一个生产变体 并且称为 XGB-Model

00:02:44.165 --> 00:02:46.100
有了端点配置后

00:02:46.100 --> 00:02:50.375
要求 SageMaker 使用这些属性创建一个端点

00:02:50.375 --> 00:02:54.470
然后测试端点 确保一切能运行

00:02:54.470 --> 00:02:59.510
首先序列化输入数据 然后发送给端点

00:02:59.510 --> 00:03:02.720
我们可以查看生成的响应

00:03:02.720 --> 00:03:05.825
与 SageMaker 中的大多数结果一样 这里的结果也是JSON 对象

00:03:05.825 --> 00:03:08.735
从 Python 的角度来看

00:03:08.735 --> 00:03:11.800
可以看做字典对象

00:03:11.800 --> 00:03:16.400
这个 response 对象包含关于模型结果的大量信息

00:03:16.400 --> 00:03:19.970
它告诉我们返回的数据的格式

00:03:19.970 --> 00:03:23.670
向其发送数据的生产变体的名称

00:03:23.670 --> 00:03:29.620
对我们来说 端点仅向一个模型发送数据

00:03:29.620 --> 00:03:33.380
所以这就是向其发送数据的变体

00:03:33.380 --> 00:03:35.540
这是 body 对象

00:03:35.540 --> 00:03:37.385
它是一个 streaming 对象

00:03:37.385 --> 00:03:40.720
为了访问 streaming 对象的内容

00:03:40.720 --> 00:03:42.625
我们需要首先读取它

00:03:42.625 --> 00:03:45.845
读取后 是一个比特流

00:03:45.845 --> 00:03:50.180
因为我们知道结果应该是实际的字符串

00:03:50.180 --> 00:03:53.345
所以需要将比特流转换成字符串

00:03:53.345 --> 00:03:57.530
可以使用 decode() 方法转换

00:03:57.530 --> 00:04:00.995
结果约为 40

00:04:00.995 --> 00:04:04.220
与真实结果并非很接近

00:04:04.220 --> 00:04:05.380
但是也接近了

00:04:05.380 --> 00:04:10.180
稍后我们还会使用 XGBoost 模型的

00:04:10.180 --> 00:04:13.640
但是暂时先关闭创建的端点

00:04:13.640 --> 00:04:17.000
接下来我们将创建第二个模型

