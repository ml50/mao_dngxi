WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.919
如果你还记得前面课程的内容

00:00:02.919 --> 00:00:07.745
编写模块化代码是软件开发中的必要实践

00:00:07.745 --> 00:00:11.660
将程序拆分为逻辑性的函数和模块

00:00:11.660 --> 00:00:14.574
下面通过一些提示指南来帮助理解

00:00:14.574 --> 00:00:17.074
首先 不要重复自己

00:00:17.074 --> 00:00:20.954
模块化使你可以复用部分代码

00:00:20.954 --> 00:00:24.574
让我们回到之前关于测试分数的例子

00:00:24.574 --> 00:00:29.744
在这里 我们有一个测试分数列表 后面以三种不同的方式变换数值

00:00:29.745 --> 00:00:32.670
假设你是一名教育工作者 出了一次很难的测试题

00:00:32.670 --> 00:00:35.929
或提出的问题有点不公平

00:00:35.929 --> 00:00:40.024
所以你决定找出一种抬高学生成绩的方法

00:00:40.024 --> 00:00:41.640
前两种方法

00:00:41.640 --> 00:00:46.969
是比较线性的变换 分别为每个分数提高 5 分和 10 分

00:00:46.969 --> 00:00:48.199
在第三种方法中

00:00:48.200 --> 00:00:49.925
应用平方根变换

00:00:49.924 --> 00:00:52.414
得出每个分数的平方根

00:00:52.414 --> 00:00:54.295
然后乘以 10

00:00:54.295 --> 00:00:56.929
现在很难理解这段代码的作用

00:00:56.929 --> 00:01:00.018
并且看起来非常重复

00:01:00.018 --> 00:01:03.019
这是 "面条式代码" 的示例

00:01:03.020 --> 00:01:07.594
在数据科学家中很常见 但并不是我们想要遵循的

00:01:07.594 --> 00:01:10.370
让我们应用编写整洁代码课程中学到的技巧

00:01:10.370 --> 00:01:15.140
使用更好的命名和可读的函数来优化这段代码

00:01:15.140 --> 00:01:19.710
可以用具有描述性的名称来表示这个分数列表

00:01:19.709 --> 00:01:24.149
比如 test_scores 然后使用 numpy 来获得每个列表的均值

00:01:24.150 --> 00:01:28.880
还可以使用列表推导式 使代码更精炼和可读

00:01:28.879 --> 00:01:32.935
为分数和结果列表使用更具有描述性的名称

00:01:32.935 --> 00:01:34.790
我们的代码现在很清晰了

00:01:34.790 --> 00:01:36.859
但仍需要更多的重构

00:01:36.859 --> 00:01:43.750
首先 应用 5 和 10 线性变换的代码行看起来非常相似

00:01:43.750 --> 00:01:47.569
我们可以将其概括为一个函数 还可以

00:01:47.569 --> 00:01:51.489
将这些打印语句整合为一个 for 循环

00:01:51.489 --> 00:01:54.405
这实际上展示了下一个提示

00:01:54.405 --> 00:01:57.974
抽象出逻辑来提高可读性

00:01:57.974 --> 00:02:03.719
我们注意到 将代码抽象为函数 不仅使其重复性降低

00:02:03.719 --> 00:02:07.935
也因描述性的函数名 提高了代码可读性

00:02:07.935 --> 00:02:13.090
可以很容易地猜到 这行代码是对测试成绩应用 5 的线性变换

00:02:13.090 --> 00:02:18.545
这一行是用 10 来做相同的变换

00:02:18.544 --> 00:02:24.189
这一行是使用平方根变换成绩曲线 下面使用 for 循环后

00:02:24.189 --> 00:02:26.770
我们不仅删除了重复的代码行

00:02:26.770 --> 00:02:30.400
也更容易理解代码的功能

00:02:30.400 --> 00:02:35.000
显然 这是在遍历四个列表 然后打印每个列表的均值

00:02:35.000 --> 00:02:37.599
请注意 尽管将逻辑抽象为函数

00:02:37.599 --> 00:02:40.954
可以使代码可读性更高

00:02:40.955 --> 00:02:45.630
但很可能会过度设计 最终拥有太多函数

00:02:45.629 --> 00:02:47.359
所以 你需要判断

00:02:47.360 --> 00:02:49.460
这引出了我们的下一个提示

00:02:49.460 --> 00:02:54.465
函数、类和模块等实体的数量最小化

00:02:54.465 --> 00:02:58.664
函数调用还是内联逻辑需要权衡

00:02:58.664 --> 00:03:03.819
如果将代码分解为很多不必要的函数和模块

00:03:03.819 --> 00:03:05.794
你就必须到处跳

00:03:05.794 --> 00:03:08.449
如果要查看某个小功能的实现详情

00:03:08.449 --> 00:03:11.514
跳来跳去查看可能并不值得

00:03:11.514 --> 00:03:14.244
这与命名变量时的考虑有些类似

00:03:14.245 --> 00:03:19.340
较长的变量名不一定等同于提高可读性

00:03:19.340 --> 00:03:22.229
创建更多模块同样也不会

00:03:22.229 --> 00:03:25.875
必然导致有效的模块化

00:03:25.875 --> 00:03:28.530
继续下一个提示

00:03:28.530 --> 00:03:31.004
确保你写的每个函数

00:03:31.004 --> 00:03:33.299
专注于做一件事

00:03:33.300 --> 00:03:36.835
例如 你不会想要这样的代码

00:03:36.835 --> 00:03:40.629
这与之前的示例相似

00:03:40.629 --> 00:03:46.435
只是每个变换函数还会打印调整后分数列表的均值

00:03:46.435 --> 00:03:51.229
要避免在函数中产生不必要的副作用 使它们保持专注

00:03:51.229 --> 00:03:56.169
即使你以这种方式重命名函数 表明会打印均值

00:03:56.169 --> 00:03:58.929
这些函数仍然是在做多件事

00:03:58.930 --> 00:04:02.188
变得更难以概括和复用

00:04:02.188 --> 00:04:08.125
通常 如果你的函数名中包含 and 请考虑重构

00:04:08.125 --> 00:04:14.243
另一个提示是 任意变量名在某些函数中可能更有效

00:04:14.243 --> 00:04:16.360
注意 在这些函数中

00:04:16.360 --> 00:04:19.759
我们打破了使用描述性变量名的规则

00:04:19.759 --> 00:04:24.879
这是因为像这样的一般函数中的任意变量名

00:04:24.879 --> 00:04:27.335
实际上可以使代码更具可读性

00:04:27.334 --> 00:04:30.689
线性变换实际上不一定针对测试得分

00:04:30.689 --> 00:04:35.634
它可以用于任何想要增加某个整数值的迭代

00:04:35.634 --> 00:04:39.839
我们的主题是撰写简单而专注的函数

00:04:39.839 --> 00:04:42.579
另一个有用的提示是

00:04:42.579 --> 00:04:45.594
尽可能不超过三个参数

00:04:45.595 --> 00:04:48.280
当然 这不是一个硬性规则

00:04:48.279 --> 00:04:51.414
有时确实多个参数更加恰当

00:04:51.415 --> 00:04:53.860
但在绝大多数情况下

00:04:53.860 --> 00:04:56.525
使用较少的参数更高效

00:04:56.524 --> 00:04:59.019
请记住 我们正在模块化

00:04:59.019 --> 00:05:02.524
以简化代码并使其更有效地使用

00:05:02.524 --> 00:05:05.354
如果你的函数有很多参数

00:05:05.355 --> 00:05:09.020
可能需要重新考虑如何拆分它

00:05:09.019 --> 00:05:11.334
通过这个小例子

00:05:11.334 --> 00:05:14.509
你看到了如何使用函数来抽象出程序的各个部分

00:05:14.509 --> 00:05:18.784
使其更可读、清晰和可复用

00:05:18.785 --> 00:05:20.720
随着算法越来越复杂

00:05:20.720 --> 00:05:22.795
这变得越来越重要

00:05:22.795 --> 00:05:25.270
特别是在数据科学工作中

