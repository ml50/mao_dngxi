WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:06.490
来看一个示例场景 其中需要优化代码以提高效率

00:00:06.490 --> 00:00:10.919
假设我们在管理商店的书籍

00:00:10.919 --> 00:00:15.070
想找到过去两年内发表的关于编程的所有书

00:00:15.070 --> 00:00:20.740
我们有一个文件 列出了过去两年出版的所有图书 ID

00:00:20.739 --> 00:00:24.854
叫做 books_published_last_two_years.txt

00:00:24.855 --> 00:00:29.940
同样还有一个所有编程书籍的文件 all_coding_books.txt

00:00:29.940 --> 00:00:35.120
既然我们想找到过去两年内出版的所有编程书籍

00:00:35.119 --> 00:00:39.640
也就是要找到这两个文件中共同包含的图书 ID

00:00:39.640 --> 00:00:42.530
你的同事想出了一种方法

00:00:42.530 --> 00:00:46.175
向你展示了获取两个文件共有书籍的代码

00:00:46.174 --> 00:00:48.059
读入两个文件后

00:00:48.060 --> 00:00:52.775
他们的策略是遍历第一个文件中的每本书

00:00:52.774 --> 00:00:55.734
检查它是否包含在第二个文件中

00:00:55.734 --> 00:00:58.899
如果是 将其添加到最终列表中

00:00:58.899 --> 00:01:02.509
这是可行的 是一种直观的方法

00:01:02.509 --> 00:01:04.924
让我们看看运行需要多长时间

00:01:04.924 --> 00:01:08.494
花了大约 13.6 秒

00:01:08.495 --> 00:01:12.290
我们可以有几种方式来提高效率

00:01:12.290 --> 00:01:18.150
这里是一些提示 首先 尽可能使用向量运算而不是循环

00:01:18.150 --> 00:01:21.405
Numpy 和 Pandas 是你最好的朋友

00:01:21.405 --> 00:01:26.299
在很多情况下都可以使用 NumPy 和 Pandas 的函数替代循环

00:01:26.299 --> 00:01:31.700
这些函数使用向量运算来使计算更快

00:01:31.700 --> 00:01:34.965
有时候可以找到对应的方法 完全满足需求

00:01:34.965 --> 00:01:37.835
其他时候 你需要有点创意

00:01:37.834 --> 00:01:41.719
这个例子就有一个你可以直接使用的有用方法

00:01:41.719 --> 00:01:44.179
让我来展示一下我是如何找到的

00:01:44.180 --> 00:01:46.415
不是开玩笑 我使用谷歌搜索

00:01:46.415 --> 00:01:49.580
如何在两个 NumPy 数组中找到共有元素

00:01:49.579 --> 00:01:51.329
这是我搜到的结果

00:01:51.329 --> 00:01:54.530
使用 NumPy 的 intersect1d 方法得到

00:01:54.530 --> 00:01:59.329
recent_books 和 coding_books 数组的交集

00:01:59.329 --> 00:02:02.420
我会给你相同的 Notebook 在这里放一个单元格

00:02:02.420 --> 00:02:05.689
这里的代码记录运行所需的时间

00:02:05.689 --> 00:02:08.564
在这一行写下你的代码行

00:02:08.564 --> 00:02:13.634
第二个提示是了解你的数据结构以及哪些方法更快

00:02:13.634 --> 00:02:16.409
除了依赖 Numpy 和 Pandas 之外

00:02:16.409 --> 00:02:20.539
通常还需要仔细检查 Python 中是否存在

00:02:20.539 --> 00:02:24.729
可用于更高效地完成任务的数据结构或方法

00:02:24.729 --> 00:02:26.669
例如 在这种情况下

00:02:26.669 --> 00:02:30.349
你还记得 Python 中的某种数据结构 可以储存

00:02:30.349 --> 00:02:35.299
一组不重复的元素 可以快速计算不同群组的交集和并集吗？

00:02:35.300 --> 00:02:38.870
那就是集合 你可以在本页底部提供的链接中

00:02:38.870 --> 00:02:43.064
了解为什么集合比此任务中的列表更高效的信息

00:02:43.064 --> 00:02:46.294
还记得我都是用谷歌搜索的这些吗？

00:02:46.294 --> 00:02:52.034
上一次 我在谷歌搜索如何在特定的 Numpy 数组中找到共同的元素

00:02:52.034 --> 00:02:56.270
但你可以搜索更加通用的关键词 比如

00:02:56.270 --> 00:02:59.450
如何找到 Python 列表中的共有元素

00:02:59.449 --> 00:03:03.099
你会看到这样的帖子 分享和比较不同的答案

00:03:03.099 --> 00:03:06.174
你可以看到这里介绍了集合

00:03:06.175 --> 00:03:09.649
这个回答貌似有很多投票

00:03:09.649 --> 00:03:13.985
不过最终我们应该尝试不同的方法 比较它们在我们的例子中的不同效率

00:03:13.985 --> 00:03:18.050
因为不同的方法在不同的情况中表现不同

00:03:18.050 --> 00:03:20.730
为自己的情况进行测试是最聪明的

00:03:20.729 --> 00:03:23.224
在 Jupyter Notebook 的下一个单元格中

00:03:23.224 --> 00:03:26.989
看看使用 Python 集合的 intersection 方法

00:03:26.990 --> 00:03:32.070
计算 recent_books 和 coding_books 的共有元素需要多长时间

00:03:32.069 --> 00:03:35.000
这里同样存在一些代码来计算代码运行时长

