WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:02.370
权重初始化的目标是

00:00:02.370 --> 00:00:04.930
在训练过程中为模型带来最好的学习机会

00:00:04.930 --> 00:00:09.990
很多模型的学习方式是通过查看犯过的错误迭代地改进自己

00:00:09.990 --> 00:00:13.140
因此我们希望模型一开始犯的错更有参考性

00:00:13.140 --> 00:00:17.760
能够为模型到底该如何改进自己提供启发和信息

00:00:17.760 --> 00:00:21.850
我们发现如果初始化为常量权重值 则满足不了这种需求

00:00:21.850 --> 00:00:25.040
因此或许有必要采取完全不同的策略

00:00:25.040 --> 00:00:28.579
如果我们将所有权重都初始化为彼此不同的唯一数字

00:00:28.579 --> 00:00:32.455
而不是全设为 0 或 1 会怎么样？

00:00:32.455 --> 00:00:35.480
最佳方式是随机选择一批唯一数字

00:00:35.480 --> 00:00:39.465
这些数字是从概率分布中抽样的数字

00:00:39.465 --> 00:00:41.720
获取随机权重的很好方法是

00:00:41.720 --> 00:00:43.820
从均匀分布中抽样

00:00:43.820 --> 00:00:49.590
均匀分布使我们能以同等概率从某个范围中挑选任何数字

00:00:49.590 --> 00:00:52.370
我们将从连续分布中挑选值

00:00:52.370 --> 00:00:55.040
因此挑选完全相同的数字的概率很低

00:00:55.040 --> 00:00:57.800
首先我将演示这些值看起来如何

00:00:57.800 --> 00:01:01.390
我将使用辅助函数将一组随机值显示为直方图

00:01:01.390 --> 00:01:04.010
使用 NumPy 的 random.uniform 函数

00:01:04.010 --> 00:01:07.170
从均匀分布中挑选随机数字

00:01:07.170 --> 00:01:11.835
此函数的输入参数包括要生成的随机值的范围上下限

00:01:11.835 --> 00:01:14.000
这个数字表示应生成 1000 个随机值

00:01:14.000 --> 00:01:18.165
范围从 -3 到 3

00:01:18.165 --> 00:01:20.075
这是生成的直方图

00:01:20.075 --> 00:01:22.115
直方图由很多长条组成

00:01:22.115 --> 00:01:25.370
长条的高与某个值的频率成正比

00:01:25.370 --> 00:01:27.800
这个直方图生成了 500 个区间

00:01:27.800 --> 00:01:31.030
分别表示 1000 个生成的值

00:01:31.030 --> 00:01:33.430
对于均匀分布

00:01:33.430 --> 00:01:36.865
大多数区间都包含两个生成的值

00:01:36.865 --> 00:01:39.960
可以从这个线条 2 看出来

00:01:39.960 --> 00:01:41.850
有些区间里

00:01:41.850 --> 00:01:44.020
有 0、1 到最多 10 个值

00:01:44.020 --> 00:01:46.450
但这只是随机情况

00:01:46.450 --> 00:01:48.950
通常 这些值应该会

00:01:48.950 --> 00:01:52.135
沿着这个范围随机分布

00:01:52.135 --> 00:01:56.030
通过从这样的分布中选择初始模型权重

00:01:56.030 --> 00:01:59.225
我们引入了随机性 应该能够帮助训练模型

00:01:59.225 --> 00:02:03.255
我们还可以对权重取值设置限制条件

00:02:03.255 --> 00:02:05.540
看了均匀分布后

00:02:05.540 --> 00:02:09.335
下面看看如果初始化为均匀权重 模型训练效果如何

00:02:09.335 --> 00:02:13.130
我将下限设为 0 上限设为 1

00:02:13.130 --> 00:02:16.025
除了在 init 类代码中初始化权重之外

00:02:16.025 --> 00:02:19.035
我还将演示另一种方式

00:02:19.035 --> 00:02:21.860
要在模型定义代码之外定义权重

00:02:21.860 --> 00:02:25.305
你可以定义一个函数 该函数会根据层级类型分配权重

00:02:25.305 --> 00:02:27.895
然后使用 model.apply(fn) 将这些权重应用到初始化模型上

00:02:27.895 --> 00:02:31.865
model.apply(fn) 会将一个函数应用到每个模型层级上

00:02:31.865 --> 00:02:35.510
在这里定义函数 weights_init_uniform

00:02:35.510 --> 00:02:38.480
此函数将应用到模型中的每个模块上

00:02:38.480 --> 00:02:41.965
在这里检查模型中是否有任何线性层级

00:02:41.965 --> 00:02:44.185
对于每个线性层级中的权重

00:02:44.185 --> 00:02:49.530
我将应用一个均匀分布 上下限分别为 0 和 1

00:02:49.530 --> 00:02:53.450
在这里将偏差设为常量 0

00:02:53.450 --> 00:02:54.480
就像在 nn.init 中一样

00:02:54.480 --> 00:02:56.600
你可以调用多种分布

00:02:56.600 --> 00:02:59.515
并以这种方式初始化网络权重

00:02:59.515 --> 00:03:03.500
还有一步 要用这些权重初始化模型

00:03:03.500 --> 00:03:05.605
我将实例化新的模型

00:03:05.605 --> 00:03:10.355
称之为 model_uniform 并设为默认的 Net()

00:03:10.355 --> 00:03:13.570
注意 我没有传入任何常量权重值

00:03:13.570 --> 00:03:15.410
要应用均匀权重

00:03:15.410 --> 00:03:19.355
我将对此模型调用 apply(weights _init_uniform)

00:03:19.355 --> 00:03:21.110
apply 将不断调用此初始化函数

00:03:21.110 --> 00:03:25.585
并将均匀权重应用到每个线性层级上

00:03:25.585 --> 00:03:28.725
同时输出关于该模型的细节信息

00:03:28.725 --> 00:03:31.580
最后创建一个长度为 1 的模型列表

00:03:31.580 --> 00:03:34.745
看看这个均匀模型的效果

00:03:34.745 --> 00:03:37.280
可以看出损失一开始依然很高

00:03:37.280 --> 00:03:39.785
但是能稳定地下降

00:03:39.785 --> 00:03:41.520
训练两轮之后

00:03:41.520 --> 00:03:45.890
模型的准确率约为 33% 比随机猜测强多了

00:03:45.890 --> 00:03:48.200
因此我们的策略方向是对的

