WEBVTT
Kind: captions
Language: zh-CN

00:00:00.790 --> 00:00:06.179
有种常用的图像分割技术 叫 k 均值聚类

00:00:06.179 --> 00:00:09.740
这是种机器学习技术 能将图像分割成若干部分

00:00:09.740 --> 00:00:13.660
方法是把具相似特征的数据点聚类或分组到一起

00:00:13.660 --> 00:00:17.565
以这张碗盛橙子图为例

00:00:17.565 --> 00:00:21.484
如果我让 k 均值将图片分成两种不同的颜色

00:00:21.484 --> 00:00:24.239
我们就会得到这样一张图像

00:00:24.239 --> 00:00:26.834
橙子以及桌上较亮的部分

00:00:26.835 --> 00:00:29.705
被视为一簇橙色的点

00:00:29.704 --> 00:00:34.789
黑暗的背景和所有阴影部分则被归为深褐色的数据点簇

00:00:34.789 --> 00:00:36.632
不过我们讲得太远了

00:00:36.633 --> 00:00:40.100
还是先来讲 k 均值是怎么一步步聚类数据的吧

00:00:40.100 --> 00:00:42.079
我们称 k 均值为

00:00:42.079 --> 00:00:46.250
非监督学习方法 也就是说你无须使用标签数据

00:00:46.250 --> 00:00:51.990
相反 非监督学习旨在分组并刻画无标签数据集

00:00:51.990 --> 00:00:56.690
而这个过程中 非监督学习往往会识别出多组数据的模式和相似之处

00:00:56.689 --> 00:01:00.394
所以你可以给 k 均值任意一个无标签数据集

00:01:00.395 --> 00:01:02.480
比如图像的像素值

00:01:02.479 --> 00:01:05.194
然后让 k 均值将这个数据集分解成 k 簇

00:01:05.194 --> 00:01:08.384
其中 k 是变量 你可以选择该变量的值

00:01:08.385 --> 00:01:09.837
对于这张橙子图

00:01:09.837 --> 00:01:11.730
我们设 k = 2

00:01:11.730 --> 00:01:13.400
如果我们增加这个值

00:01:13.400 --> 00:01:15.195
假设 k 等于 3 或 6

00:01:15.194 --> 00:01:18.314
图像就会分成三个或六个颜色不同的部分

00:01:18.314 --> 00:01:20.269
这个时候 这些部分

00:01:20.269 --> 00:01:23.060
会把橙子和桌子不同的阴影部分分开来

00:01:23.060 --> 00:01:26.504
我们来看一个简单的例子 更具体地探讨 k 均值

00:01:26.504 --> 00:01:31.414
这张图很小 只有 34 乘 34 像素 是彩虹的一部分

00:01:31.415 --> 00:01:35.465
我要用 k 均值 根据颜色将这张图分为三簇

00:01:35.465 --> 00:01:41.030
首先 我们知道这张图里的每个像素都有一个 RGB 值

00:01:41.030 --> 00:01:47.570
事实上 我们可以将各像素值当作 RGB 颜色空间的数据点绘制出来

00:01:47.569 --> 00:01:51.089
这些轴分别对应 R、G 和 B 的值

00:01:51.090 --> 00:01:53.185
注意这些轴上的值

00:01:53.185 --> 00:01:54.981
这里最高的 R、G、B 值

00:01:54.980 --> 00:01:56.044
假设接近白色

00:01:56.045 --> 00:01:58.879
会在这上面的角落里

00:01:58.879 --> 00:02:00.484
如果我们转动一下这个空间

00:02:00.484 --> 00:02:04.530
就能发现这些点自然而然地按颜色聚类了

00:02:04.530 --> 00:02:08.689
如果我让 k 均值将这些图像数据分成三簇

00:02:08.689 --> 00:02:11.479
那么 k 均值就会观察这些像素值 随机猜测

00:02:11.479 --> 00:02:15.935
三个 RGB 点 将数据分成三簇

00:02:15.935 --> 00:02:19.265
我们将这三个点称为中心点 A、B 和 C

00:02:19.264 --> 00:02:21.979
然后 k 均值会进行赋值

00:02:21.979 --> 00:02:26.840
把各像素值赋给最近的中心点所在的簇

00:02:26.840 --> 00:02:30.050
所以在左边的所有这些像素都属于 A 簇

00:02:30.050 --> 00:02:32.340
靠近右边的则归入 B 簇

00:02:32.340 --> 00:02:33.575
底部的

00:02:33.574 --> 00:02:35.144
则归入 C 簇

00:02:35.145 --> 00:02:37.784
这里我把三者标成颜色不同的区域

00:02:37.784 --> 00:02:44.025
然后 k 均值会分别取各簇所有 RGB 值的实际平均数 也就是均值

00:02:44.025 --> 00:02:48.460
然后将三个中心点更新为相对应的均值

00:02:48.460 --> 00:02:52.502
我们退一步来讲 以 A 簇为例

00:02:52.502 --> 00:02:58.765
k 均值会观察这个簇里的所有像素值 计算出其中所有 RGB 的平均值

00:02:58.764 --> 00:03:00.924
就称为均值 A 吧

00:03:00.925 --> 00:03:05.750
然后 k 均值会更新中心点 A 的位置 换成这个平均值所处的位置

00:03:05.750 --> 00:03:08.590
这就是我一开始将这些点称为中心点的原因了

00:03:08.590 --> 00:03:11.349
因为它们就该是所属簇的中心

00:03:11.349 --> 00:03:13.879
k 均值会对 B 簇的中心点 B

00:03:13.879 --> 00:03:17.159
和 C 簇的中心点 C 进行同样的处理

00:03:17.159 --> 00:03:21.669
将之前猜测出来的中心点移动到簇均值的位置上

00:03:21.669 --> 00:03:23.405
重复这个过程

00:03:23.405 --> 00:03:26.000
根据调整后的新中心点

00:03:26.000 --> 00:03:28.715
形成新簇

00:03:28.715 --> 00:03:30.979
然后再次计算簇均值 更新均值

00:03:30.979 --> 00:03:34.139
随后再次更新中心点

00:03:34.139 --> 00:03:38.989
有点像是数据点会相互拉扯 从而形成新的中心点

00:03:38.990 --> 00:03:42.439
这个过程会不断重复

00:03:42.439 --> 00:03:47.164
基本上 每次迭代后 中心点的移动幅度都会变小

00:03:47.164 --> 00:03:49.819
算法会不断重复这个步骤

00:03:49.819 --> 00:03:53.439
直至收敛 而收敛程度是由我们定义的

00:03:53.439 --> 00:03:56.675
通常算法会在一定迭代次数后收敛 比如 10 次

00:03:56.675 --> 00:04:01.160
或根据每次迭代后中心点的移动幅度来确定是否要收敛

00:04:01.159 --> 00:04:04.400
如果中心点的移动幅度小于某个较小的值

00:04:04.400 --> 00:04:06.590
比如某次迭代时 移动幅度只有一像素

00:04:06.590 --> 00:04:10.784
那么中心点就收敛了 算法会终止

00:04:10.784 --> 00:04:16.209
最后得到的中心点便具有最佳的数据分类效果

00:04:16.209 --> 00:04:19.000
接下来 我们来看看怎么用代码实现聚类

