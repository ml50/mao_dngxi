WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:06.330
为了创建新的 DataFrame 并填充新的 PCA 成分数据 我编写了这些代码

00:00:06.330 --> 00:00:08.205
首先创建一个全新的 DataFrame

00:00:08.205 --> 00:00:11.519
其中包含所有新转换的数据

00:00:11.519 --> 00:00:16.004
然后遍历 PCA 成分数据中的每个数据点

00:00:16.004 --> 00:00:18.989
从之前看到的结果中获取成分值

00:00:18.989 --> 00:00:20.834
包括标签“projection”

00:00:20.835 --> 00:00:23.234
以及float32_tensor.values

00:00:23.234 --> 00:00:25.259
然后传入这个成分列表

00:00:25.260 --> 00:00:27.915
并将其附加到 counties_transformed DataFrame

00:00:27.914 --> 00:00:32.399
这个是每个数据点的所有 33 个 PCA 成分

00:00:32.399 --> 00:00:38.234
接下来 像 counties_scaled DataFrame 一样 按照 State-County 设定索引

00:00:38.234 --> 00:00:40.320
相应地设定索引

00:00:40.320 --> 00:00:43.625
我知道我只想保留前 n 个成分

00:00:43.625 --> 00:00:45.905
不想保留所有 33 个特征

00:00:45.905 --> 00:00:47.734
例如保留前七位

00:00:47.734 --> 00:00:50.929
并且知道它们按照最不重要到最重要排序

00:00:50.929 --> 00:00:53.090
与之前的处理方式相似

00:00:53.090 --> 00:00:54.470
获取起始索引

00:00:54.469 --> 00:00:58.219
然后从该索引一直到最后 选定一些数据

00:00:58.219 --> 00:01:01.774
然后反向返回截断的 DataFrame

00:01:01.774 --> 00:01:06.260
最高的成分将是这个转换后 DataFrame 的第一列

00:01:06.260 --> 00:01:11.225
现在运行代码并传入 n_top_components 的值来创建新数据

00:01:11.224 --> 00:01:13.519
我将创建前七位成分的数据

00:01:13.519 --> 00:01:16.179
因为我知道前七位可以捕获 80% 的数据方差

00:01:16.180 --> 00:01:19.550
调用 create_transformed_df 函数

00:01:19.549 --> 00:01:23.299
传入每个数据点的 PCA 成分数据

00:01:23.299 --> 00:01:25.625
以及原始 counties_scaled DataFrame

00:01:25.625 --> 00:01:28.655
最后将 n_top_components 设为 7

00:01:28.655 --> 00:01:30.305
这就是生成的 DataFrame

00:01:30.305 --> 00:01:32.630
依然按 State-County 设定索引

00:01:32.629 --> 00:01:36.079
具有从 1-7 的成分值

00:01:36.079 --> 00:01:38.000
再执行一个步骤

00:01:38.000 --> 00:01:41.015
这些列名称是个数值

00:01:41.015 --> 00:01:44.000
我将采用更加描述性的列名称

00:01:44.000 --> 00:01:46.275
例如 c_1 c_2 c_3 一直到 c_7

00:01:46.275 --> 00:01:49.550
你也可以设为其他名称

00:01:49.549 --> 00:01:52.909
我获得了郡县列表及其成分值

00:01:52.909 --> 00:01:54.709
转换数据后

00:01:54.709 --> 00:01:57.379
我不再需要 PCA 模型端点

00:01:57.379 --> 00:02:00.875
可以通过调用SageMaker session.delete_endpoint 删除端点

00:02:00.875 --> 00:02:04.209
传入 PCA 预测器的名称

00:02:04.209 --> 00:02:08.150
不使用资源后 一定要删除资源

00:02:08.150 --> 00:02:11.420
否则可能会产生额外的处理或存储费

00:02:11.419 --> 00:02:15.244
Ok下面总结下我们执行的步骤

00:02:15.245 --> 00:02:17.900
我们先定义了 PCA 模型

00:02:17.900 --> 00:02:19.830
然后用格式化的数据训练模型

00:02:19.830 --> 00:02:22.250
接着通过使用 mxnet 库加载模型文件

00:02:22.250 --> 00:02:26.310
查看了训练过的模型的属性

00:02:26.560 --> 00:02:31.849
我们查看了前 n 个成分解释的方差

00:02:31.849 --> 00:02:36.169
并决定在最终分析时使用前七个主成分

00:02:36.169 --> 00:02:39.739
我们还查看了组成每个成分的特征权重

00:02:39.740 --> 00:02:41.330
这样可以更好地描述

00:02:41.330 --> 00:02:44.315
组成转换后训练数据的成分

00:02:44.314 --> 00:02:46.699
最终为了创建转换后数据

00:02:46.699 --> 00:02:49.174
我们部署了训练过的 PCA 模型

00:02:49.175 --> 00:02:51.680
并将其应用到 NumPy 训练数据上

00:02:51.680 --> 00:02:54.155
我们创建了新的转换后 DataFrame

00:02:54.155 --> 00:02:58.460
这些就是训练和部署 SageMaker 模型的过程 演示的内容比较多

00:02:58.460 --> 00:03:01.780
我把一些数据清理和转换步骤留给你来完成

00:03:01.780 --> 00:03:05.120
接下来 请练习部署你自己的模型

00:03:05.120 --> 00:03:10.069
我将布置一些关于训练和部署 K 均值聚类模型的练习

00:03:10.069 --> 00:03:13.849
最后这个模型的创建方式与 PCA 模型相似

00:03:13.849 --> 00:03:15.799
你需要定义 K 均值 estimator

00:03:15.800 --> 00:03:19.790
传入相应的参数并用新转换的数据训练它

00:03:19.789 --> 00:03:23.239
请仔细阅读下面的练习和说明

00:03:23.240 --> 00:03:25.270
看看是否能全部完成

00:03:25.270 --> 00:03:27.740
最终部署 K 均值模型

00:03:27.740 --> 00:03:30.379
甚至提取出训练过的模型的属性

00:03:30.379 --> 00:03:31.909
如果你遇到错误

00:03:31.909 --> 00:03:35.155
请通过日志和跟踪记录正常地调试

00:03:35.155 --> 00:03:37.699
我将提供一些说明

00:03:37.699 --> 00:03:39.979
以及相关文档的链接

00:03:39.979 --> 00:03:42.409
帮助你向 K 均值模型传入正确的参数

00:03:42.409 --> 00:03:44.719
最终目标是

00:03:44.719 --> 00:03:47.509
向每个数据点分配聚类

00:03:47.509 --> 00:03:49.884
并且问 第一 应该把每个郡县分配到哪个聚类？

00:03:49.884 --> 00:03:53.584
第二 这对于成分和特征级组成来说是什么意思？

00:03:53.585 --> 00:03:55.250
这些问题可以帮助我们描述

00:03:55.250 --> 00:03:59.580
郡县之间的一般相似性和差异

