WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:03.629
我们知道 每个主成分都是

00:00:03.629 --> 00:00:06.990
这里的原始特征的加权线性组合

00:00:06.990 --> 00:00:12.300
看到前几个成分可以解释大部分数据方差后

00:00:12.300 --> 00:00:16.019
有必要看看每个成分到底是怎么组成的

00:00:16.019 --> 00:00:17.699
哪些特征定义了每个成分

00:00:17.699 --> 00:00:19.530
在下个单元格中

00:00:19.530 --> 00:00:25.170
有一个完整的函数 display_component 它的参数包括成分权重列表 v

00:00:25.170 --> 00:00:29.200
特征列表 即 counties dataframe 的列名称

00:00:29.199 --> 00:00:33.950
成分数量 例如最高成分 前两个 前三个 等等

00:00:33.950 --> 00:00:36.455
以及要显示的前几个权重的数量

00:00:36.454 --> 00:00:39.939
它可以是 1-34 之间的任何数字

00:00:39.939 --> 00:00:44.084
默认情况下 我将显示前 10 个最重要的特征权重

00:00:44.085 --> 00:00:47.755
Ok逐行解释下 与 s dataframe 相似

00:00:47.755 --> 00:00:51.575
我将获取指向目标成分的行对应的行索引

00:00:51.575 --> 00:00:56.270
查看靠近 v dataframe 末尾的一行

00:00:56.270 --> 00:01:01.000
因为成分按照最不重要到最重要排练 与 s 一样

00:01:01.000 --> 00:01:04.129
然后获取成分的特征权重列表

00:01:04.129 --> 00:01:06.439
即 v dataframe 中的这行

00:01:06.439 --> 00:01:08.974
获取权重值列表

00:01:08.974 --> 00:01:11.454
值列表存储在 v_1 中

00:01:11.454 --> 00:01:13.405
然后根据列表推导式

00:01:13.405 --> 00:01:17.629
将这些权重值与特征列表变成一个 dataframe

00:01:17.629 --> 00:01:22.609
这个将提供对应于特定特征名称的一行权重值

00:01:22.609 --> 00:01:25.370
这个将提供一个成分 dataframe

00:01:25.370 --> 00:01:28.550
我希望按照权重值排序

00:01:28.549 --> 00:01:32.539
我将按照重要性顺序显示权重

00:01:32.540 --> 00:01:34.100
为了查找最重要的权重

00:01:34.099 --> 00:01:36.769
我将查看每个权重的大小

00:01:36.769 --> 00:01:41.689
即权重的绝对值 然后对这些值排序

00:01:41.689 --> 00:01:44.545
在这里获取前 n 个权重

00:01:44.545 --> 00:01:46.980
最后 使用 seaborn 显示库

00:01:46.980 --> 00:01:50.655
绘制一个条形图 其中显示了这些权重值

00:01:50.655 --> 00:01:51.954
特征名称

00:01:51.954 --> 00:01:55.325
并且包含所传入成分数量的标题

00:01:55.325 --> 00:01:59.350
看看最高成分的图形

00:01:59.349 --> 00:02:02.329
我们知道最高成分可以解释

00:02:02.329 --> 00:02:05.539
训练数据中约 32% 的数据方差

00:02:05.540 --> 00:02:09.230
并且对于白人或在人口调查中确认为白人的人口来说

00:02:09.229 --> 00:02:13.269
权重为负并且为负的程度很高

00:02:13.270 --> 00:02:17.659
对于西班牙裔或非裔人口来说权重为正

00:02:17.659 --> 00:02:22.729
并且对于贫穷水平和就业水平来说也为正

00:02:22.729 --> 00:02:25.459
我们可以回到该函数部分 传入更高的权重数量

00:02:25.460 --> 00:02:28.135
从而显示更精细的结果

00:02:28.134 --> 00:02:32.224
可以更详细地看到政府工作 私人工作和职业类型

00:02:32.224 --> 00:02:36.629
要注意的一点是 这些单个特征并非独立

00:02:36.629 --> 00:02:41.164
这些类别的离散性表明有些数据始终被忽略

00:02:41.164 --> 00:02:46.759
例如 种族和社会经济学机会经常交织在一起

00:02:46.759 --> 00:02:49.549
使某些特征的关系更紧密

00:02:49.550 --> 00:02:52.430
这些种族类别充当涵盖性术语

00:02:52.430 --> 00:02:55.569
并不能始终发现人口的复杂性细节

00:02:55.569 --> 00:02:58.459
作为数据科学家和机器学习开发人员

00:02:58.460 --> 00:03:00.860
思考为何一开始要收集这样的数据

00:03:00.860 --> 00:03:04.480
以及它在描述人口方面有哪些限制很重要

00:03:04.479 --> 00:03:08.629
建议你用批判的眼光观察任何数据来源

00:03:08.629 --> 00:03:12.859
这样可以更好地判断最终能从数据中发现什么样的规律

00:03:12.860 --> 00:03:14.840
我们再看一个成分

00:03:14.840 --> 00:03:16.500
在分析数据时

00:03:16.500 --> 00:03:18.104
查看成分细分信息

00:03:18.104 --> 00:03:22.280
有助于了解稍后训练数据是如何聚类的

00:03:22.280 --> 00:03:26.240
例如 在创建降维数据时

00:03:26.240 --> 00:03:31.175
如果我们发现某个郡县的成分 2 值很高

00:03:31.175 --> 00:03:35.555
我们就知道它是由这些正权重和负权重特征混合而成

00:03:35.555 --> 00:03:39.200
现在你可以使用该函数查看任何成分的组成了

00:03:39.199 --> 00:03:41.974
接下来 我们将部署此 PCA 模型

00:03:41.974 --> 00:03:44.049
获取前七个成分

00:03:44.050 --> 00:03:47.880
并创建新的降维训练数据

