WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.665
我们加载了数据 第一步是清理和探索数据

00:00:04.665 --> 00:00:08.535
数据探索是机器学习工作流程的最重要环节之一

00:00:08.535 --> 00:00:12.810
因为我们可以发现数据分布和特征的初始规律

00:00:12.810 --> 00:00:17.144
并根据这些规律继续建模和聚类数据

00:00:17.144 --> 00:00:21.675
我在上面以 counties_df 的形式加载了 CSV 文件

00:00:21.675 --> 00:00:25.425
我在这里输出了该 DataFrame 的行数和列数

00:00:25.425 --> 00:00:30.630
然后沿着 axis=0 对该 DataFrame 调用 .dropna

00:00:30.629 --> 00:00:34.500
表示我将删除任何数据不完整的行

00:00:34.500 --> 00:00:38.609
并将整洁的 DataFrame 保存为 clean_counties_df

00:00:38.609 --> 00:00:41.975
然后输出形状 看看删除了多少行数据

00:00:41.975 --> 00:00:43.070
如果运行此单元格

00:00:43.070 --> 00:00:49.250
可以看出 一开始有 3,220 个数据点 有 37 列

00:00:49.250 --> 00:00:50.750
在这个清理步骤之后

00:00:50.750 --> 00:00:53.015
我删除了 2 行数据

00:00:53.015 --> 00:00:56.079
现在有 3,218 个数据点

00:00:56.079 --> 00:01:00.935
Ok 接下来继续处理数据时 我将使用这个整洁的数据

00:01:00.935 --> 00:01:03.215
接着 我将创建新的 DataFrame

00:01:03.215 --> 00:01:06.500
按照 State-County 设定索引 而不是采用单键索引

00:01:06.500 --> 00:01:09.750
对于 clean_counties_df 中的每个数据点

00:01:09.750 --> 00:01:12.325
都有一个 State 和 County 值

00:01:12.325 --> 00:01:15.980
我可以使用短划线将这两个字符串合并到一起

00:01:15.980 --> 00:01:18.454
然后 为了根据此值设定 DataFrame 的索引

00:01:18.454 --> 00:01:24.275
我将调用 clean_counties_df.index 并设为新的 State-County 值

00:01:24.275 --> 00:01:26.090
这是第一步

00:01:26.090 --> 00:01:29.359
现在这里不是单键索引

00:01:29.359 --> 00:01:32.674
我用由 State 和 Country 两列构成的唯一键值来索引数据

00:01:32.674 --> 00:01:34.414
但是我还没有删除任何行

00:01:34.415 --> 00:01:37.460
可以看到这个 state 和 county 对应于该索引

00:01:37.459 --> 00:01:41.029
所以现在这两列是多余的 可以删除

00:01:41.030 --> 00:01:43.310
我还将删除 Censusid 列

00:01:43.310 --> 00:01:46.700
它并不能提供关于这些郡县的任何有意义信息

00:01:46.700 --> 00:01:48.980
在下个单元格中完成这项任务

00:01:48.980 --> 00:01:52.075
我指定了要删除的每列的名称

00:01:52.075 --> 00:01:54.680
然后对 clean_counties_df 调用 .drop

00:01:54.680 --> 00:01:57.680
创建新的 clean_counties_df

00:01:57.680 --> 00:01:59.480
显示几个数据点看看

00:01:59.480 --> 00:02:01.655
现在获得了我想要的 DataFrame

00:02:01.655 --> 00:02:03.335
它们按照 State-County 设定索引

00:02:03.334 --> 00:02:05.765
并且列是数值特征

00:02:05.765 --> 00:02:10.159
列数从 37 个变成了 34 个

00:02:10.159 --> 00:02:13.685
我可以在这里输出整个特征值列表

00:02:13.685 --> 00:02:18.159
这些是 clean_counties_df 中的所有列名称列表

00:02:18.159 --> 00:02:20.025
包括总人口

00:02:20.025 --> 00:02:21.599
男性和女性人数

00:02:21.599 --> 00:02:24.900
种族人数 劳动力人数 以及其他数据

00:02:24.900 --> 00:02:26.780
我们已经完成这一步

00:02:26.780 --> 00:02:28.979
创建了整洁的 clean_counties DataFrame

00:02:28.979 --> 00:02:31.579
下面可以可视化这些数据

00:02:31.580 --> 00:02:35.075
看看所有郡县的数据分布情况

00:02:35.074 --> 00:02:36.530
下一步

00:02:36.530 --> 00:02:39.305
我将比较一些特征 进一步了解数据

00:02:39.305 --> 00:02:42.319
在下个单元格中 我将显示特征的直方图

00:02:42.319 --> 00:02:47.269
展示数据点在离散特征范围内的分布情况

00:02:47.270 --> 00:02:50.555
首先 列出我要比较的特征列表

00:02:50.555 --> 00:02:53.689
我选择了几种交通类型

00:02:53.689 --> 00:02:56.539
这些记录为通勤类型

00:02:56.539 --> 00:02:59.030
人们开车 拼车 坐公共交通

00:02:59.030 --> 00:03:02.094
步行 还是通过其他方式上下班？

00:03:02.094 --> 00:03:03.504
从我的 DataFrame 中可以看出

00:03:03.504 --> 00:03:07.129
所有这些特征都用百分比表示

00:03:07.129 --> 00:03:10.189
所有这些图形的 x 轴是可比较的

00:03:10.189 --> 00:03:12.389
对于 transport_list 中的每个特征

00:03:12.389 --> 00:03:16.159
我将创建一个直方图 按照名称

00:03:16.159 --> 00:03:18.379
从 clean_counties_df 中获取特征值

00:03:18.379 --> 00:03:21.034
并指定直方图的区间数量

00:03:21.034 --> 00:03:25.039
这个直方图表示开车上班的人

00:03:25.039 --> 00:03:28.474
每个区间都描述了某个特征范围

00:03:28.474 --> 00:03:30.185
即百分点

00:03:30.185 --> 00:03:32.210
例如约 0-5

00:03:32.210 --> 00:03:35.710
5-10 等百分点范围

00:03:35.710 --> 00:03:39.920
y 轴表示有多少数据点落入这些区间

00:03:39.919 --> 00:03:43.814
表示有多少郡县落入特定的特征范围

00:03:43.814 --> 00:03:45.064
数据有一定的分散性

00:03:45.064 --> 00:03:47.159
可以看出 在各个郡县

00:03:47.159 --> 00:03:50.780
人们通常有 70%-85% 左右的时间是开车上下班

00:03:50.780 --> 00:03:54.055
在接近 0% 左右还有一个小峰值

00:03:54.055 --> 00:03:58.564
向下滚动 可以看到每个县的拼车数据

00:03:58.564 --> 00:04:02.134
大部分县的人约 10% 的时候拼车

00:04:02.134 --> 00:04:05.104
下面是公共交通和步行数据

00:04:05.104 --> 00:04:07.625
直观地来讲 这些数据比较合理

00:04:07.625 --> 00:04:09.979
我认为使用公共交通和步行的人主要集中在大城市

00:04:09.979 --> 00:04:14.209
这些大城市的交通体系已经成熟

00:04:14.210 --> 00:04:17.199
并且只有小部分人群乘坐公共交通或步行也合理

00:04:17.199 --> 00:04:20.495
注意 我尚未创建任何聚类

00:04:20.495 --> 00:04:23.149
只是查看郡县的人

00:04:23.149 --> 00:04:25.734
是如何分类自己的通勤方式的

00:04:25.735 --> 00:04:28.785
甚至还可以更改区间数量

00:04:28.785 --> 00:04:32.270
查看更详细的数据分布情况

00:04:32.269 --> 00:04:35.194
这只是一个交通数据示例

00:04:35.194 --> 00:04:37.685
该数据集中还有很多其他特征

00:04:37.685 --> 00:04:39.319
布置一道选择完成的练习

00:04:39.319 --> 00:04:42.079
请创建一组你自己的直方图

00:04:42.079 --> 00:04:44.089
按照你感兴趣的一组特征

00:04:44.089 --> 00:04:46.609
绘制直方图

00:04:46.610 --> 00:04:49.040
接下来 你需要归一化数据

00:04:49.040 --> 00:04:52.410
并为训练 PCA 模型做准备

