WEBVTT
Kind: captions
Language: zh-CN

00:00:00.000 --> 00:00:04.335
你已经自己填写了此 notebook

00:00:04.335 --> 00:00:07.245
下面看看我的答案

00:00:07.245 --> 00:00:12.435
我已经运行了所有的数据下载和处理步骤

00:00:12.435 --> 00:00:15.180
可以直接从第 4 步开始

00:00:15.180 --> 00:00:16.950
从这步开始需要添加代码

00:00:16.950 --> 00:00:22.425
首先 将训练集拆分成训练和验证集

00:00:22.425 --> 00:00:28.215
我们有 25,000 条影评 已经随机化排列影评

00:00:28.215 --> 00:00:31.470
为了拆分出训练集和验证集

00:00:31.470 --> 00:00:34.680
我们将前 10,000 条作为验证集

00:00:34.680 --> 00:00:39.290
并将剩下的作为训练集

00:00:39.290 --> 00:00:44.940
然后就像在 Boston Housing notebook 中一样

00:00:44.940 --> 00:00:47.560
将测试集 验证集和训练集

00:00:47.560 --> 00:00:53.585
保存到 csv 文件中并放到指定的 /data 目录下

00:00:53.585 --> 00:00:56.360
并且和 Boston Housing 数据集一样

00:00:56.360 --> 00:01:01.175
在保存 csv 文件时 不要包含标题或索引

00:01:01.175 --> 00:01:07.470
因为 SageMaker 要求数据文件是这样的格式

00:01:07.470 --> 00:01:11.285
保存好测试 验证和训练集后

00:01:11.285 --> 00:01:15.245
先管理下内存

00:01:15.245 --> 00:01:17.570
你将在很多 notebook 中

00:01:17.570 --> 00:01:21.740
看到这种代码 原因是

00:01:21.740 --> 00:01:25.100
Notebook 实例运行所在的默认虚拟机

00:01:25.100 --> 00:01:28.700
没有太多的内存

00:01:28.700 --> 00:01:32.270
如果我们只是让不使用的数据留在那

00:01:32.270 --> 00:01:35.705
可能会在 notebook 中耗尽内存

00:01:35.705 --> 00:01:37.025
有两种解决方案

00:01:37.025 --> 00:01:39.305
我们可以增加

00:01:39.305 --> 00:01:42.445
notebook 所在的虚拟机的内存

00:01:42.445 --> 00:01:44.070
但是这样会带来成本

00:01:44.070 --> 00:01:47.480
或者可以这样跟踪内存

00:01:47.480 --> 00:01:51.170
并且释放不再使用的内存

00:01:51.170 --> 00:01:55.000
下一步是将数据文件上传到 S3

00:01:55.000 --> 00:01:59.975
方法和在 Boston Housing notebook 中一样

00:01:59.975 --> 00:02:02.780
唯一的区别是更改 prefix

00:02:02.780 --> 00:02:09.015
prefix 相当于在某个驱动器上的文件夹名称

00:02:09.015 --> 00:02:16.410
该驱动器是此 notebook 对应的默认驱动器或存储桶

00:02:16.410 --> 00:02:19.955
然后 使用 upload_data 方法

00:02:19.955 --> 00:02:23.780
将每个数据文件上传到 S3

00:02:23.780 --> 00:02:26.690
上传了数据文件后 继续下一步

00:02:26.690 --> 00:02:30.455
首先获取执行角色

00:02:30.455 --> 00:02:35.970
角色描述了 notebook 可以访问的其他资源

00:02:35.970 --> 00:02:41.540
我们需要为要创建的 estimator 提供一个角色

00:02:41.540 --> 00:02:44.815
我们可以提供与此 notebook 一样的角色

00:02:44.815 --> 00:02:48.830
还需要为 XGBoost 算法创建镜像 URI

00:02:48.830 --> 00:02:53.200
取决于当前使用的区域

00:02:53.200 --> 00:02:55.975
我们使用 get_image_uri 方法

00:02:55.975 --> 00:03:00.425
然后像在 Boston Housing notebook 中一样

00:03:00.425 --> 00:03:04.400
创建 SageMaker estimator 对象

00:03:04.400 --> 00:03:09.710
区别在于其中一个 XGBoost 超参数

00:03:09.710 --> 00:03:12.515
因为我们要判断情感

00:03:12.515 --> 00:03:16.865
情感结果是二元的正面或负面情感

00:03:16.865 --> 00:03:22.290
所以需要使用二元回归

00:03:22.290 --> 00:03:26.830
我们通常使用逻辑回归

00:03:26.830 --> 00:03:31.670
Boston Housing notebook 与此 notebook 的真正唯一区别是

00:03:31.670 --> 00:03:36.685
我们将这里的 objective 改成了二元逻辑回归

00:03:36.685 --> 00:03:41.030
Ok定义了 XGBoost 模型后 我们需要拟合该模型

00:03:41.030 --> 00:03:43.550
就像在 Boston Housing notebook 中一样

00:03:43.550 --> 00:03:48.095
我们只需提供训练集和验证集就可以了

00:03:48.095 --> 00:03:49.880
拟合模型后

00:03:49.880 --> 00:03:53.675
我们可以测试模型 看看模型的效果

00:03:53.675 --> 00:03:57.545
首先需要新建一个 transformer 对象

00:03:57.545 --> 00:04:00.015
创建完毕后 设置转换作业

00:04:00.015 --> 00:04:05.240
需要指定测试数据的位置

00:04:05.240 --> 00:04:06.890
数据类型

00:04:06.890 --> 00:04:12.200
以及有必要的话 指定 SageMaker 拆分数据的方式

00:04:12.200 --> 00:04:15.370
注意 转换作业

00:04:15.370 --> 00:04:16.940
会在后台运行

00:04:16.940 --> 00:04:21.530
我们可以使用 wait() 方法直观地看看

00:04:21.530 --> 00:04:26.420
转换作业的进展以及何时运行完毕

00:04:26.420 --> 00:04:28.740
转换作业运行完毕后

00:04:28.740 --> 00:04:34.445
我们可以将转换作业的输出复制到 notebook 实例中

00:04:34.445 --> 00:04:38.165
然后读取数据 看看模型的表现

00:04:38.165 --> 00:04:40.475
不太糟糕 准确率几乎达到 87%

00:04:40.475 --> 00:04:43.220
我们可以选择完成清理步骤

00:04:43.220 --> 00:04:47.600
删除在整个 notebook 中创建的所有文件搞定

00:04:47.600 --> 00:04:50.970
你在 SageMaker 中创建了你的首个模型

00:04:50.970 --> 00:04:53.060
当然 我们使用了

00:04:53.060 --> 00:04:56.375
很多 SageMaker 高阶功能

00:04:56.375 --> 00:04:58.810
所以大部分工作都在后台完成了

00:04:58.810 --> 00:05:01.010
在接下来的几个视频中

00:05:01.010 --> 00:05:05.130
我们将非常详细地了解 SageMaker 的运行原理

